% !TEX root = ../main.tex
\section{Design}\label{sec:design} % System design (platform independent)
% High-level account of software structure and how it works
% Algorithms used & comparison with alternatives
% Main design decisions taken and justification

In the app's most basic form of design, much of the logic exists within central `presenter' classes, with small amounts of code for updating the app's UI\@. There are sensor listeners to grab data from the smartphone's sensors for tracking a skydive, and a local database exists to store persistent data gathered from the user and sensors.

\subsection{Platform}
The decision was made to create the app for Android mobile devices since these offer the easiest access to sensors, OS features and have an extensive amount of support available online. Apple's iOS was ruled out since only the iPhone 6, and newer devices contain a barometer currently. These devices cost a small fortune when compared to the spare Android phones with barometers that some people have lying around that could be used for testing.

\subsection{Model View Presenter}
The Model View Presenter (MVP) design pattern was chosen for this project. Model View Presenter puts much of the logic in the `presenter', where the presenter acts like the bridge between the view and the model. The view contains minimal code and is only responsible for updating what the user sees and passing actions on to the presenter. The model is where data is stored such as data relating to the current state of the program; the presenter may subscribe to changes to this data to inform the view of updates. The view and the model do not communicate with each other directly. MVP was chosen over Model View Controller (MVC) since in MVC nearly all of the logic is in the `controller', where it is expected to return the correct view in response to an action in the current view. MVC does not split logic between all elements of the design pattern; the controller handles everything, and the view knows as little as possible and only exists to render what the user sees. Views and their related presenters of the MVP design pattern allow for code to be separated more evenly.

The app is designed in a way that allows for flexible and re-usable back-end elements. Figure~\vref{fig:app-structure} shows how the app is structured.

\begin{figure}[ht]
  \centering
  \begin{scaletikzpicturetowidth}{\linewidth}
    \begin{tikzpicture}[squarednode/.style={rectangle, draw=black}]
      \node[squarednode] (view) {View};
      \node[squarednode] (presenter) [right=of view] {Presenter};
      \node[squarednode] (model) [right=of presenter] {Model};
      \node[squarednode] (listener) [above=of presenter] {Sensor Listeners};
      \node[squarednode] (database) [above=of model] {Database};

      \draw[<->] (view.east)--(presenter.west);
      \draw[<->] (presenter.east)--(model.west);
      \draw[<->] (listener.south)--(presenter.north);
      \draw[<->] (model.north)--(database.south);
    \end{tikzpicture}
  \end{scaletikzpicturetowidth}
  \caption{High-level app structure}\label{fig:app-structure}
\end{figure}

Every element in Figure~\vref{fig:app-structure} may contain more than one element. The view contains each separate screen to be shown in the app. There are many presenters, one for each view, handling the logic behind a view and updating and reacting to the app's state. There are several different models containing data that can be accessed by presenters.

Data from the sensor listeners need to be stored in either a model for temporary storage or the database for persistence; this is done via a presenter to keep all setting and getting of data going through one central access point.

The database talks only to the models, these models contain ways for a presenter to get, set and subscribe to data that is stored in either the model or the database. The presenters need to be able to subscribe to data changes so that they can keep the app's state up-to-date, for example updating the view to show a new value for some stored data.

\subsection{Altitude Calculation}
The smartphone's barometer will be used to output atmospheric pressure readings. Atmospheric pressure readings can be used to calculate altitude relative to another point~\cite{he_atmospheric_2012, liu_beyond_2014}, this calculation is defined as:
\begin{equation}\label{eq:altitude-calculation}
  H = \frac{T_0}{L} \cdot \left({\left(\frac{P}{P_0}\right)}^{-\frac{L \cdot R}{g}} - 1\right)
\end{equation}
where
\begin{description}
  \item $H$: altitude (\si{\metre})
  \item $T_0$: standard air temperature (\si{\kelvin})
  \item $L$: temperature lapse rate (\si{\kelvin\per\metre})
  \item $P$: air pressure (\si{\pascal})
  \item $P_0$: reference air pressure (\si{\pascal})
  \item $R$: specific gas constant for air (\si{\joule\kilogram\kelvin})
  \item $g$: gravitational acceleration (\si{\metre\per\second\squared})
\end{description}

All values except pressures and temperature are constants.

Another equation for calculating altitude is the international barometric formula~\cite{bosch_bmp180:_2018}, defined as:
\begin{equation}\label{eq:barometric-fomula}
  H = 44330 \cdot \left(1 - {\left(\frac{P}{P_0}\right)}^{\frac{1}{5.255}}\right)
\end{equation}
where
\begin{description}
  \item $H$: altitude (\si{\metre})
  \item $P$: air pressure (\si{\hPa})
  \item $P_0$: reference air pressure (\si{\hPa})
\end{description}

The benefit of this equation is that it does not require an input temperature. If we used an algorithm that needed a temperature input value, another requirement would be placed on the phone running the app that states that the phone must have a programmatically accessible temperature sensor. This equation should be accurate up to \SI{9000}{\metre}, which is double the altitude of a typical skydive. Since this international barometric formula is more straightforward and yet still reliable, it was chosen to be used within the app for calculating altitudes.

\subsection{Geographic Coordinates}
For calculating geographic coordinates after a move of a distance in a bearing, we needed a specific equation since cartesian coordinate equations would not work. The world is not flat.

One equation that was found to work for calculating a position after a move is defined as~\cite{m_david_stackoverflow:_????}:
\begin{align}
  \begin{split}
    \mathrm{Lat} ={} &\arcsin\left(\sin(O_{\mathrm{lat}}) \cdot \cos\left(\frac{D}{R}\right) \right. \\
                     &\left.+ \cos(O_{\mathrm{lat}}) \cdot \sin\left(\frac{D}{R}\right) \cdot \cos(B)\right)
  \end{split}\label{eq:move-in-lat}\\
  \begin{split}
    \mathrm{Lon} ={} &O_{\mathrm{lon}} \\
                     & + \arctantwo\left(\frac{}{}\right. \\
                     &\left.\quad\sin(B) \cdot \sin\left(\frac{D}{R}\right) \cdot \cos(O_{\mathrm{lat}}),\right. \\
                     &\left.\quad\cos\left(\frac{D}{R}\right) - \sin(O_{\mathrm{lat}}) \cdot \sin(O_{\mathrm{lat}})\right)
  \end{split}\label{eq:move-in-lon}
\end{align}
where
\begin{description}
  \item $O_{\mathrm{lat}}$: origin latitude (\si{\deg})
  \item $O_{\mathrm{lon}}$: origin longitude (\si{\deg})
  \item $B$: bearing (\si{\radian})
  \item $D$: distance (\si{\kilo\metre})
  \item $R$: 6378.1 (approximate earth radius in \si{\kilo\metre})
  \item $\mathrm{Lat}$: result latitude (\si{\radian})
  \item $\mathrm{Lon}$: result longitude (\si{\radian})
\end{description}

This equation has been included in the app design as it does much of the work of the landing pattern calculations and is repeatedly used.

\subsection{Landing Pattern Planning}\label{subsec:landing-pattern}
The app can show a landing pattern for a user-specified target landing area based on user-specified landing pattern turn heights and current wind conditions at the landing area.

Landing pattern generation could be done one of two ways, either we pick a landing pattern start point and attempt to calculate safe turn heights to get to the landing area, or we work backwards from the landing area to calculate where each turn should be for preferred heights. The latter is the logical choice since for the landing pattern generation; we are telling the user where they should start their landing pattern for optimal results rather than having a restriction on that and working between two set points.

A user can set their preferred landing pattern turn altitudes as well as their canopy airspeed and glide ratio; these are used in calculating an appropriate landing pattern.
%A user might select their downwind leg to begin at \SI{300}{\metre}, base leg at \SI{180}{\metre} and upwind at \SI{90}{\metre}.

The first step for calculating the landing pattern for a given target area is finding the current wind conditions at that location. For this we can use almost any online weather API, all we need is wind speed and direction. We chose to pull this weather data from the~\citetitle{openweathermap_openweathermap_????}~\cite{openweathermap_openweathermap_????} which can return JSON responses.

Using the user's canopy airspeed and glide ratio, we calculate the canopy's fall rate using Equation~\vref{eq:fallrate}. As mentioned in Section~\ref{sec:further-background}, the fall rate of a canopy can be considered constant with no toggle input.

Figure~\vref{fig:pattern-generation} labels the order in which we calculate the turns heights, upwind leg first (1), then base (2), and then downwind (3).
To calculate the upwind leg of the landing pattern, we take the final turn altitude (P3) and calculate how far the canopy can travel upwind from this altitude using the constant time taken to reach the target and the ground speed of the canopy moving upwind.

\begin{figure}[ht]
  \centering
  \begin{scaletikzpicturetowidth}{0.5 * \linewidth}
    \begin{tikzpicture}[scale=\tikzscale]
      \begin{scope}[very thick,
        decoration={markings,
        mark=at position 0.5 with {\arrow{>}}}
        ]
        % Target
        \draw[red,fill] (0,-3) circle(0.25) node[black,align=center,left=1mm]{Landing\\Area};

        % Path
        \draw[postaction={decorate}] (4,-8)--(4,0) node[at start,right]{P1} node[midway,right]{3}; % downwind
        \draw[postaction={decorate}] (4,0)--(0,0) node[at start,above]{P2} node[midway,above]{2}; % base
        \draw[postaction={decorate}] (0,0)--(0,-3) node[at start,above]{P3}node[midway,left]{1}; %upwind

        % Wind
        \draw[blue,->] (0,-7.5)--(0,-5) node[black,align=center,midway,left]{Wind\\Direction};
      \end{scope}
    \end{tikzpicture}
  \end{scaletikzpicturetowidth}
  \caption{A typical skydiver landing pattern}\label{fig:pattern-generation}
\end{figure}

We calculate the time taken to reach the destination altitude (the landing area in this case) as $T = \frac{\delta A}{F}$, where $T$ is the time taken (\si{\second}), $\delta A$ is the difference in altitude (\si{\metre}) and $F$ is the fall rate (\si{\metre\per\second}).

When calculating the upwind leg of the landing pattern, we subtract the wind speed from the canopy airspeed to get the ground speed for that part of the pattern. We can then calculate the distance that the canopy can travel into the wind as $D = G \cdot T$ where $D$ is the distance to be travelled (\si{\metre}), $G$ is the ground speed (\si{\metre\per\second}) and $T$ is the time taken (\si{\second}).

Now that we have the distance that the canopy can travel in the upwind leg, we calculate a move \SI{180}{\degree} from the wind direction (downwind) of the calculated distance by feeding these values and the target latitude and longitude into Equations~\ref{eq:move-in-lat} and~\ref{eq:move-in-lon}. The resulting latitude and longitude are the coordinates that P3 should take in the landing pattern.

To calculate the remaining coordinates for the landing pattern turn altitudes, we follow the same procedure as the upwind leg but modify the canopy ground speed and direction in which a move is made. For example, for calculating the coordinates for P1, we would be calculating a move from P2 in the wind direction for a ground speed of airspeed + wind speed.

\subsection{Text to Speech}
Since we would like to be able to communicate with the user during canopy flight for landing pattern guidance and safety warnings, text to speech was decided to be used. A user is not likely to be able to see their phone screen during a jump, and we would not want them looking at it regardless, since it may distract them from their skydiving drills. Since it is quite loud while under canopy, a user is expected to wear a Bluetooth earpiece so that we can feed them voice messages related to their jump.

Examples of messages that were planned for the user:
\begin{itemize}
  \item ``\textit{At 180 metres, turn left, across the wind.}''
  \item ``\textit{Proximity warning: skydiver within 5 metres}''
\end{itemize}

The proximity warning begins with the word ``proximity'', this is so that the first thing the skydiver hears immediately alerts them to start checking their airspace for dangers.

\subsection{Landing Pattern Guidance}
How to do live landing pattern guidance was a harder problem to solve since the order in which the turns are calculated, how they are calculated and what aspects of the pattern are most important were not clearly defined for skydivers.

The solution mainly revolves around the fact that because the plane dropping skydivers will fly into the wind, skydivers should only ever be dropped downwind, upwind or at the ideal drop location and not too far across the wind. Due to this, we can assume that the base leg of the landing pattern will always be between the altitudes required to get from the current location to directly in line with the target landing area. With this assumption, the landing pattern generated will always be either directly upwind or downwind of the target location even if the guidance cannot get the user directly to the landing area. All that remains to adjust are downwind and upwind legs.

To calculate the recommended landing pattern for the user, we calculate where the user would land if they followed a typical landing pattern based on their current trajectory, such as the one shown in Figure~\ref{fig:landing-pattern}. Calculating the user's destination can be done by following the steps used to generate a landing pattern in Section~\ref{subsec:landing-pattern} but done in reverse with the position the user is expected to be at for the start of the landing pattern as the starting point.
From this point, we can calculate how far from the target landing area the user is expected to land. If the expected landing location is over a certain distance from the target landing area, then we recalculate the landing pattern based on this distance.

If the user's estimated current trajectory is too far upwind of the landing area, we reduce the altitudes of turns P2 and P3 shown in Figure~\ref{fig:pattern-generation}, thus reducing the distance that the user can travel upwind. We can calculate the amount that the altitude must be reduced by rearranging the equations used to calculate the distance that can be travelled between altitudes, stated in Section~\ref{subsec:landing-pattern}. If the user's estimated current trajectory is too far downwind, then the same must be done but with an increase in the altitudes of turns P2 and P3. The effects of changing landing pattern turn altitudes can be seen in Figure~\vref{fig:pattern-adjustments}.

If reducing the altitudes of the turns will result in dangerously low turns, the starting altitude of the landing pattern should be increased instead if possible to extend the range of the downwind leg.

\begin{figure*}[ht]
  \centering
  \begin{scaletikzpicturetowidth}{0.85 * \linewidth}
    \begin{tikzpicture}[scale=\tikzscale]
      \begin{scope}[very thick,
        decoration={markings,
        mark=at position 0.5 with {\arrow{>}}}
        ]

        %%%%
        %% Pattern 1
        %%%%%
        % Target
        \draw[red,fill] (0,-1) circle(0.25);

        % Path
        \draw[postaction={decorate}] (4,-8)--(4,1) node[at start,right]{\SI{300}{\metre}}; % downwind
        \draw[postaction={decorate}] (4,1)--(0,1) node[at start,above]{\SI{180}{\metre}}; % base
        \draw[postaction={decorate}] (0,1)--(0,-1) node[at start,above]{\SI{90}{\metre}}; %upwind

        %%%%
        %% Pattern 2
        %%%%
        % Target
        \draw[red,fill] (10,-3) circle(0.25);

        % Path
        \draw[postaction={decorate}] (14,-8)--(14,0) node[at start,right]{\SI{300}{\metre}}; % downwind
        \draw[postaction={decorate}] (14,0)--(10,0) node[at start,above]{\SI{190}{\metre}}; % base
        \draw[postaction={decorate}] (10,0)--(10,-3) node[at start,above]{\SI{100}{\metre}}; %upwind

        %%%%
        %% Pattern 3
        %%%%
        % Target
        \draw[red,fill] (20,-5) circle(0.25);

        % Path
        \draw[postaction={decorate}] (24,-8)--(24,-1) node[at start,right]{\SI{300}{\metre}}; % downwind
        \draw[postaction={decorate}] (24,-1)--(20,-1) node[at start,above]{\SI{200}{\metre}}; % base
        \draw[postaction={decorate}] (20,-1)--(20,-5) node[at start,above]{\SI{110}{\metre}}; %upwind

      \end{scope}
    \end{tikzpicture}
  \end{scaletikzpicturetowidth}
  \caption{Adjustments of landing pattern turn altitudes}\label{fig:pattern-adjustments}
\end{figure*}

\paragraph{An Example}
Consider a skydiver that can travel \SI{225}{\metre} upwind from an altitude of \SI{90}{\metre} with a ground speed of \SI{15}{\metre\per\second} and fall rate of \SI{6}{\metre\per\second}. If the skydiver is expected to travel \SI{15}{\metre} too far upwind, we can calculate the change that must be made to the altitude to land on target. We subtract the \SI{15}{\metre} from \SI{225}{\metre} to get the distance that we would like the skydiver to travel (\SI{210}{\metre}). We then put this value into the following equation:
\begin{equation}
  \mathrm{Time} = \frac{\mathrm{Distance}}{\mathrm{Ground Speed}}
\end{equation}
This tells us that for the adjusted value, we want them to be descending from their last turn for
\SI{14}{\second}.
We then put the time that we got this equation into the following equation to calculate the altitude that the final turn should be at in the landing pattern:
\begin{equation}
  \mathrm{Altitude} = \mathrm{Time} \times \mathrm{Fall Rate}
\end{equation}
This gives us an altitude of \SI{84}{\metre} in this example, a reduction of \SI{6}{\metre} from the original altitude. The second-last turn altitude must also be reduced by this amount to complete the new landing pattern.

\subsection{Proximity Warnings}
Users of the app can be given proximity warnings via text to speech through a Bluetooth earpiece; these are warnings that inform the user of anyone being within a configurable dangerous distance after canopy flight has been detected.
The feature requires that two people flying within proximities warranting a warning both have the app running with both devices capable of communicating with each other.

Bluetooth was initially considered for the communication technology to be used in the proximity warnings feature since it is widely supported and is set to have mesh network in future versions. Mesh networks would allow for a dynamic platform for many devices to communicate through during a skydive. Unfortunately, as mentioned in Section~\ref{sec:related-work}, Bluetooth does not have a considerable range. For this reason, Wi-Fi communication was chosen as the communication technology instead.

Wi-Fi has a much more significant range and bandwidth than Bluetooth and so is be more suited to fulfil the long-range requirement that we have for proximity warnings. Unfortunately, there are no Wi-Fi mesh networking capabilities on smartphones, meaning that the app should instead cycle through connections to different devices or select one device as a host for many other devices to connect to. Cycling through many different connections would add latency to the receiving of positional data for any user since no data could be transferred between two users until the connection cycle returns to that connection. Selecting one device as a host for many other devices to connect to makes much more sense since all data can be sent to the host and re-dispersed out to all clients. With this method, all clients can be aware of each other's positions with fewer re-connections required.

\subsection{Freefall and Canopy Deploy Detection}
After contacting several skydiving altimeter manufacturers and receiving either no response or being declined any information, we had to design our freefall detection parameters from scratch.

The app should only log data from the point that a skydiver jumps from the plane to when they land on the ground. To detect freefall, we set a couple of prerequisites that must be met. Firstly, the altitude should be over a safe skydiving altitude of \SI{1500}{\metre} and secondly, the fall rate calculated for the user must pass \SI{20}{\metre\per\second}. The fall rate is reached \SI{\approx2}{\second} after jumping from the plane.

Canopy flight will only ever happen after some freefall, and so for canopy flight detection, the first prerequisite is that freefall must have already been detected. The next prerequisite is that the fall rate must have dropped below \SI{15}{\metre\per\second}.
